
## 插值查找

### 基于有序序列和二分查找，是对二分查找的优化

遵循以下公式：
    （目标值 - 最小值）/ （最大值 - 最小值）≈（目标值下标 - 最小值下标）/（最大值下标 - 最小值下标）
    目标值下标 = （目标值 - 最小值）/ （最大值 - 最小值）* （最大值下标 - 最小值下标） + 最小值下标
```js
    var arr = [4, 1, 6, 9, 3, 2, 8, 7, 5];

    function exchange(arr, a, b) {
        var temp = arr[a];
        arr[a] = arr[b];
        arr[b] = temp;
    }

    // 排序
    function quickSort(arr, begin, end) {
        if (arr == null || arr.length == 0) return;
        if (begin >= end - 1) return;
        var left = begin;
        var right = end;
        do {
            do left++; while (left < right && arr[left] < arr[begin])
            do right--; while (left < right && arr[right] > arr[begin]);
            if (left < right) exchange(arr, left, right);
        } while (left < right);
        var exchangePoint = left == right ? right - 1 : right;
        exchange(arr, begin, exchangePoint);
        quickSort(arr, begin, exchangePoint);
        quickSort(arr, exchangePoint + 1, end);
        return arr;
    }

    // 插值查找
    function insertSearch(arr, target) {
        if (arr == null || arr.length == 0) return false;
        var minIndex = 0;
        var maxIndex = arr.length - 1;
        while (minIndex <= maxIndex) {
            var mid = (target - arr[minIndex]) / (arr[maxIndex] - arr[minIndex]) * (maxIndex - minIndex) + minIndex;
            if (arr[mid] == target) {
                return true;
            } else if (arr[mid] > target) {
                maxIndex = mid - 1;
            } else {
                minIndex = mid + 1;
            }
        }
        return false;
    }

    var newArr = quickSort(arr, 0, arr.length);
    var result = insertSearch(arr, 10);
    console.log(result);
```